import{_ as a,c as s,o as l,ae as t}from"./chunks/framework.tuuL-SzM.js";const n="/java-img/image-20230924233734604.png",h="/java-img/image-20230924235307920.png",e="/java-img/image-20230925232633951.png",p="/java-img/image-20230926000450497.png",k="/java-img/image-20230927235634766.png",b=JSON.parse('{"title":"Java 基础 个人笔记","description":"","frontmatter":{},"headers":[],"relativePath":"Java/Java基础个人笔记.md","filePath":"Java/Java基础个人笔记.md"}'),d={name:"Java/Java基础个人笔记.md"};function r(o,i,g,c,u,E){return l(),s("div",null,i[0]||(i[0]=[t(`<h1 id="java-基础-个人笔记" tabindex="-1">Java 基础 个人笔记 <a class="header-anchor" href="#java-基础-个人笔记" aria-label="Permalink to &quot;Java 基础 个人笔记&quot;">​</a></h1><blockquote><p>记录适合自己的笔记，不适合新手观看</p></blockquote><h2 id="java-基础" tabindex="-1">Java 基础 <a class="header-anchor" href="#java-基础" aria-label="Permalink to &quot;Java 基础&quot;">​</a></h2><h3 id="字面量" tabindex="-1">字面量 <a class="header-anchor" href="#字面量" aria-label="Permalink to &quot;字面量&quot;">​</a></h3><ul><li><p>字符类型与字符串类型</p><p>字符串用双引号括起来，而单引号括起来的内容只有一个：&quot;HelloWorld&quot;，&#39;a&#39;，&#39;0&#39;，&#39;中&#39;</p></li></ul><h3 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h3><table tabindex="0"><thead><tr><th>数据类型</th><th>关键字</th><th>取值范围</th><th>内存占用</th></tr></thead><tbody><tr><td>整数</td><td>byte</td><td>-128~127</td><td>1</td></tr><tr><td></td><td>short</td><td>-32768~32767</td><td>2</td></tr><tr><td></td><td>int</td><td>-2147483648~2147483647（10 位）</td><td>4</td></tr><tr><td></td><td>long</td><td>-9223372036854775808~9223372036854775807（19 位）</td><td>8</td></tr><tr><td>浮点数</td><td>float</td><td>-3.401298e-38 到 3.402823e+38</td><td>4</td></tr><tr><td></td><td>double</td><td>-4.9000000e-324 到 1.797693e+308</td><td>8</td></tr><tr><td>字符</td><td>char</td><td>0-65535</td><td>2</td></tr><tr><td>布尔</td><td>boolean</td><td>true，false</td><td>1</td></tr></tbody></table><p>定义变量层面：定义 long 类型的变量，需要在数据值的后面加上一个 L 作为后缀，定义 float 类型的变量，需要在数据值后面加上一个 F 作为后缀</p><h3 id="算术运算" tabindex="-1">算术运算 <a class="header-anchor" href="#算术运算" aria-label="Permalink to &quot;算术运算&quot;">​</a></h3><blockquote><p>取值范围：byte &lt; short &lt; int &lt; long &lt; float &lt; double</p></blockquote><ol><li><p>隐式转换</p><ul><li>转换规则： <ul><li>数据类型不一样，不能进行计算，需要转成一样的才能进行计算，取值范围小的和取值范围大的进行运算，小的会先提升为大的（隐式转换），再进行运算。</li><li>byte、short、char 三种类型的数据在运算的时候，都会直接先提升为 int，然后再进行运算</li></ul></li></ul></li><li><p>显示转换（强转</p><ul><li><p>如果把一个取值范围大的数值，赋值给取值范围小的变量。是不允许直接赋值的。如果一定要这么做就需要加入强制转换，有可能会导致转换错误。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a;</span></span></code></pre></div></li></ul></li><li><p>计组复习（原码、反码、补码</p><blockquote><p>1 个字节范围-128~127</p></blockquote><ul><li><p>原码</p><p>规则：<strong>十进制数据的二进制表现形式，最左边的是符号位，0 为正，1 为负</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01111111</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 127</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11111111</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // -127</span></span></code></pre></div><p>利用原码进行计算的时候，如果是正数没有问题，但是如果是负数计算，结果就出错，实际运算方向，跟正确的运算方向是相反的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -1 + 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10000001</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 00000001</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // =&gt; 10000010</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // -2</span></span></code></pre></div></li><li><p>反码</p><p>为了解决原码不能计算负数的问题出现。规则：<strong>正数的反码不变，负数的反码在原码的基础上，符号位不变。数值取反，0 变 1，1 变 0。</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//-1 + 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11111110</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 00000001</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // =&gt; 11111111，是-0的反码</span></span></code></pre></div><p>负数运算的时候，如果结果不跨 0，是没有任何问题的，但是如果结果跨 0，跟实际结果会有 1 的偏差</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//-0 + 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11111111</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 00000001</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // =&gt; 00000000，为+0</span></span></code></pre></div></li><li><p>补码</p><p>为了解决负数计算时跨 0 的问题而出现的。规则：<strong>正数的补码不变，负数的补码在反码的基础上+1</strong>。另外补码还能多记录一个特殊的值-128，该数据在 1 个字节下，没有原码和反码。所以计算机中的存储和计算都是以补码的形式进行的。</p></li></ul></li><li><p>原理</p><ul><li><p>隐式转换</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0000 1010（1个字节）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0000 0000 0000 0000 0000 0000 0000 1010（4个字节）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>显示转换</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0000 0000 0000 0000 0000 0000 1100 1000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)a; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1100 1000（补码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -56</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul></li></ol><h3 id="java-内存分配" tabindex="-1">java 内存分配 <a class="header-anchor" href="#java-内存分配" aria-label="Permalink to &quot;java 内存分配&quot;">​</a></h3><ul><li>栈：方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行，方法执行完毕后出栈</li><li>堆：存储对象或者数组，通过 new 来创建的，都存储在堆内存中</li><li>方法区：存储可以运行的 class 文件</li><li>本地方法栈：JVM 在使用操作系统功能的时候使用，与开发无关</li><li>给 cpu 使用，与开发无关</li></ul><h2 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-label="Permalink to &quot;面向对象&quot;">​</a></h2><h3 id="构造方法" tabindex="-1">构造方法 <a class="header-anchor" href="#构造方法" aria-label="Permalink to &quot;构造方法&quot;">​</a></h3><ul><li>作用：在创建对象的时候给成员变量进行赋值的</li><li>特点： <ol><li>方法名与类名相同，大小写也要一致</li><li>没有返回值类型，连 void 也没有</li></ol></li><li>执行时机： <ol><li>创建对象的时候由虚拟机调用，不能手动调用构造方法</li><li>每创建一次对象，就会调用一次构造方法</li></ol></li><li>注意事项 1. 如果没有定义构造方法，系统将给出一个默认的无参数构造方法，如果定义了构造方法，系统不再提供默认的构造方法 1. 有参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这叫构造方法的重载 1. 开发建议无论是否使用，都手动书写上无参构造方法和有参构造方法。</li></ul><p><img src="`+n+'" alt="image-20230924233734604"></p><h3 id="this-的内存原理" tabindex="-1">this 的内存原理 <a class="header-anchor" href="#this-的内存原理" aria-label="Permalink to &quot;this 的内存原理&quot;">​</a></h3><ul><li>作用：区分局部变量和成员变量</li><li>本质：所在方法调用者的地址值</li></ul><p><img src="'+h+'" alt="image-20230924235307920"></p><h3 id="stringbuilder-stringjoiner" tabindex="-1">StringBuilder&amp;StringJoiner <a class="header-anchor" href="#stringbuilder-stringjoiner" aria-label="Permalink to &quot;StringBuilder&amp;StringJoiner&quot;">​</a></h3><p>StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的</p><p>作用：提高字符串的操作效率</p><p>StringJoiner 用于字符串拼接，可以指定间隔字符，还可以指定前缀与后缀</p><p><img src="'+e+'" alt="image-20230925232633951"></p><h3 id="字符串原理" tabindex="-1">字符串原理 <a class="header-anchor" href="#字符串原理" aria-label="Permalink to &quot;字符串原理&quot;">​</a></h3><ol><li>存储的内存原理 <ul><li>直接赋值会复用字符串常量池中的</li><li>new 出来的不会复用，而是开辟一个新的空间</li></ul></li><li>==号比较 <ul><li>基本数据类型比较数据值</li><li>引用数据类型比较地址值</li></ul></li><li>字符串拼接底层原理 <ul><li>如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串</li><li>如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存。</li></ul></li></ol><h3 id="集合" tabindex="-1">集合 <a class="header-anchor" href="#集合" aria-label="Permalink to &quot;集合&quot;">​</a></h3><p>集合与数组的对比：</p><ul><li>长度：数组长度固定，集合的长度可变</li><li>数组可以存储基本数据类型和引用数据类型，而集合只能存储引用数据类型，基本类型可以使用包装类，比如 int-&gt;Integer，char-&gt;Character，其余都是首字符大写</li></ul><h4 id="arraylist" tabindex="-1">ArrayList <a class="header-anchor" href="#arraylist" aria-label="Permalink to &quot;ArrayList&quot;">​</a></h4><blockquote><p>仅记录使用层面，原理后续补上</p></blockquote><p><img src="'+p+'" alt="image-20230926000450497"></p><h3 id="static-关键字" tabindex="-1">static 关键字 <a class="header-anchor" href="#static-关键字" aria-label="Permalink to &quot;static 关键字&quot;">​</a></h3><blockquote><p>static 表示静态，是 Java 中的一个修饰符，可以修饰成员变量、成员方法</p></blockquote><ul><li><p>被 static 修饰的成员变量，叫做静态变量</p><ol><li>特点 <ul><li>被该类所有实例的对象所共享</li><li>不属于实例对象，属于类</li><li>随着类的加载而加载，优先于对象存在于堆内存的静态区（JDK8 以后</li></ul></li><li>调用方式 <ul><li>类名调用（推荐</li><li>实例对象调用</li></ul></li></ol></li><li><p>被 static 修饰的成员方法，叫做静态方法</p><blockquote><p>一般会将工具类的构造方法 private 私有化，不让外部 new 实例对象，因为没有意义</p></blockquote><ol><li>特点 <ul><li>多用在测试类和工具类中</li><li>Javabean 类中很少会用</li></ul></li><li>调用方式 <ul><li>类名调用（推荐</li><li>对象名调用</li></ul></li></ol></li><li><p>注意事项</p><ol><li>静态方法只能访问静态变量和静态方法</li><li>非静态方法可以访问所有</li><li>静态方法中没有 this 关键字（因为 this 代表调用者本身的地址，静态代表共享，所以 Java 是这样设计的</li></ol></li></ul><h3 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h3><ol><li>Java 只能单继，即一个类只能继承一个直接父类，不支持多继承，但是支持多层继承</li><li>Java 中所有的类都直接或间接继承与 Object 类</li><li>子类只能访问父类中非私有的成员</li><li>继承中成员变量访问特点：就近原则</li></ol><p>当父类的方法不能满足子类现在的需求时，需要进行方法重写，即子类书写父类一样的方法声明，并在方法上加上@Override 注解</p><ul><li>继承中的构造方法 <ul><li>子类不能继承父类的构造方法，但是可以通过 super 调用</li><li>子类构造方法的第一行，有一个默认的 super()，默认先访问父类中的无参构造方法，再执行自己，保证父类数据初始化</li><li>如果想要在子类中调用父类的有参构造，必须手动书写</li></ul></li></ul><p><img src="'+k+'" alt="image-20230927235634766"></p><blockquote><p>后续待学：集合进阶-Map、Stream 流、异常、文件、IO 流、多线程、网络编程、反射</p></blockquote>',42)]))}const v=a(d,[["render",r]]);export{b as __pageData,v as default};
