# Java 基础 个人笔记

> 记录适合自己的笔记，不适合新手观看

## Java 基础

### 字面量

- 字符类型与字符串类型

  字符串用双引号括起来，而单引号括起来的内容只有一个："HelloWorld"，'a'，'0'，'中'

### 数据类型

| 数据类型 | 关键字  | 取值范围                                          | 内存占用 |
| -------- | ------- | ------------------------------------------------- | -------- |
| 整数     | byte    | -128~127                                          | 1        |
|          | short   | -32768~32767                                      | 2        |
|          | int     | -2147483648~2147483647（10 位）                   | 4        |
|          | long    | -9223372036854775808~9223372036854775807（19 位） | 8        |
| 浮点数   | float   | -3.401298e-38 到 3.402823e+38                     | 4        |
|          | double  | -4.9000000e-324 到 1.797693e+308                  | 8        |
| 字符     | char    | 0-65535                                           | 2        |
| 布尔     | boolean | true，false                                       | 1        |

定义变量层面：定义 long 类型的变量，需要在数据值的后面加上一个 L 作为后缀，定义 float 类型的变量，需要在数据值后面加上一个 F 作为后缀

### 算术运算

> 取值范围：byte < short < int < long < float < double

1. 隐式转换

   - 转换规则：
     - 数据类型不一样，不能进行计算，需要转成一样的才能进行计算，取值范围小的和取值范围大的进行运算，小的会先提升为大的（隐式转换），再进行运算。
     - byte、short、char 三种类型的数据在运算的时候，都会直接先提升为 int，然后再进行运算

2. 显示转换（强转

   - 如果把一个取值范围大的数值，赋值给取值范围小的变量。是不允许直接赋值的。如果一定要这么做就需要加入强制转换，有可能会导致转换错误。

     ```java
     double a = 12.3;
     int b = (int)a;
     ```

3. 计组复习（原码、反码、补码

   > 1 个字节范围-128~127

   - 原码

     规则：**十进制数据的二进制表现形式，最左边的是符号位，0 为正，1 为负**

     ```java
     01111111    // 127
     11111111    // -127
     ```

     利用原码进行计算的时候，如果是正数没有问题，但是如果是负数计算，结果就出错，实际运算方向，跟正确的运算方向是相反的。

     ```java
     // -1 + 1
     10000001 + 00000001 // => 10000010  // -2
     ```

   - 反码

     为了解决原码不能计算负数的问题出现。规则：**正数的反码不变，负数的反码在原码的基础上，符号位不变。数值取反，0 变 1，1 变 0。**

     ```java
     //-1 + 1
     11111110 + 00000001 // => 11111111，是-0的反码
     ```

     负数运算的时候，如果结果不跨 0，是没有任何问题的，但是如果结果跨 0，跟实际结果会有 1 的偏差

     ```java
     //-0 + 1
     11111111 + 00000001 // => 00000000，为+0
     ```

   - 补码

     为了解决负数计算时跨 0 的问题而出现的。规则：**正数的补码不变，负数的补码在反码的基础上+1**。另外补码还能多记录一个特殊的值-128，该数据在 1 个字节下，没有原码和反码。所以计算机中的存储和计算都是以补码的形式进行的。

4. 原理

   - 隐式转换

     ```java
     public class Test {
         public static void main(String[] args) {
             byte a = 10;  // 0000 1010（1个字节）
             int b = a; // 0000 0000 0000 0000 0000 0000 0000 1010（4个字节）
             System.out.println(b);
         }
     }
     ```

   - 显示转换

     ```java
     public class Test {
         public static void main(String[] args) {
             int a = 200;  // 0000 0000 0000 0000 0000 0000 1100 1000
             byte b = (byte)a; // 1100 1000（补码
             System.out.println(b); // -56
         }
     }
     ```

### java 内存分配

- 栈：方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行，方法执行完毕后出栈
- 堆：存储对象或者数组，通过 new 来创建的，都存储在堆内存中
- 方法区：存储可以运行的 class 文件
- 本地方法栈：JVM 在使用操作系统功能的时候使用，与开发无关
- 给 cpu 使用，与开发无关

## 面向对象

### 构造方法

- 作用：在创建对象的时候给成员变量进行赋值的
- 特点：
  1. 方法名与类名相同，大小写也要一致
  2. 没有返回值类型，连 void 也没有
- 执行时机：
  1. 创建对象的时候由虚拟机调用，不能手动调用构造方法
  2. 每创建一次对象，就会调用一次构造方法
- 注意事项 1. 如果没有定义构造方法，系统将给出一个默认的无参数构造方法，如果定义了构造方法，系统不再提供默认的构造方法 1. 有参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这叫构造方法的重载 1. 开发建议无论是否使用，都手动书写上无参构造方法和有参构造方法。

![image-20230924233734604](/java-img\image-20230924233734604.png)

### this 的内存原理

- 作用：区分局部变量和成员变量
- 本质：所在方法调用者的地址值

![image-20230924235307920](/java-img\image-20230924235307920.png)

### StringBuilder&StringJoiner

StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的

作用：提高字符串的操作效率

StringJoiner 用于字符串拼接，可以指定间隔字符，还可以指定前缀与后缀

![image-20230925232633951](/java-img\image-20230925232633951.png)

### 字符串原理

1. 存储的内存原理
   - 直接赋值会复用字符串常量池中的
   - new 出来的不会复用，而是开辟一个新的空间
2. ==号比较
   - 基本数据类型比较数据值
   - 引用数据类型比较地址值
3. 字符串拼接底层原理
   - 如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串
   - 如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存。

### 集合

集合与数组的对比：

- 长度：数组长度固定，集合的长度可变
- 数组可以存储基本数据类型和引用数据类型，而集合只能存储引用数据类型，基本类型可以使用包装类，比如 int->Integer，char->Character，其余都是首字符大写

#### ArrayList

> 仅记录使用层面，原理后续补上

![image-20230926000450497](/java-img\image-20230926000450497.png)

### static 关键字

> static 表示静态，是 Java 中的一个修饰符，可以修饰成员变量、成员方法

- 被 static 修饰的成员变量，叫做静态变量

  1. 特点
     - 被该类所有实例的对象所共享
     - 不属于实例对象，属于类
     - 随着类的加载而加载，优先于对象存在于堆内存的静态区（JDK8 以后
  2. 调用方式
     - 类名调用（推荐
     - 实例对象调用

- 被 static 修饰的成员方法，叫做静态方法

  > 一般会将工具类的构造方法 private 私有化，不让外部 new 实例对象，因为没有意义

  1. 特点
     - 多用在测试类和工具类中
     - Javabean 类中很少会用
  2. 调用方式
     - 类名调用（推荐
     - 对象名调用

- 注意事项

  1. 静态方法只能访问静态变量和静态方法
  2. 非静态方法可以访问所有
  3. 静态方法中没有 this 关键字（因为 this 代表调用者本身的地址，静态代表共享，所以 Java 是这样设计的

### 继承

1. Java 只能单继，即一个类只能继承一个直接父类，不支持多继承，但是支持多层继承
2. Java 中所有的类都直接或间接继承与 Object 类
3. 子类只能访问父类中非私有的成员
4. 继承中成员变量访问特点：就近原则

当父类的方法不能满足子类现在的需求时，需要进行方法重写，即子类书写父类一样的方法声明，并在方法上加上@Override 注解

- 继承中的构造方法
  - 子类不能继承父类的构造方法，但是可以通过 super 调用
  - 子类构造方法的第一行，有一个默认的 super()，默认先访问父类中的无参构造方法，再执行自己，保证父类数据初始化
  - 如果想要在子类中调用父类的有参构造，必须手动书写

![image-20230927235634766](/java-img\image-20230927235634766.png)

> 后续待学：集合进阶-Map、Stream 流、异常、文件、IO 流、多线程、网络编程、反射
