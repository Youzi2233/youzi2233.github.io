# 动态规划

动态规划（dynamic programming, DP）是一种将复杂问题分解成更小的问题来解决的优化技术。
运用动态规划解决问题时，要遵循三个重要步骤：

1. 定义子问题；
2. 实现要反复执行来解决子问题的部分；
3. 识别并求解出基线条件

## 背包问题

> 背包问题是有一个组合优化问题。它可以描述如下：给定一个固定大小、能够携带重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。

![背包问题](/算法-img/背包问题.png)

假设有如下物品重量及其价值，我们可以列出一个表格，当背包重量为n时，对应的最佳总价值是多少

| 重量 | 价值 | 物品id | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 2    | 6    | 0      | 0    | 0    | 6    | 6    | 6    | 6    | 6    | 6    | 6    | 6    | 6    |
| 2    | 3    | 1      | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 9    | 9    | 9    | 9    |
| 6    | 5    | 2      | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 9    | 11   | 11   | 14   |
| 5    | 4    | 3      | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 10   | 11   | 13   | 14   |
| 4    | 6    | 4      | 0    | 0    | 6    | 6    | 9    | 9    | 12   | 12   | 15   | 15   | 15   |

1. 我们可以很容易的构建出第一行，就是背包重量大于物品时，最优价值就是该物品总价值。

2. 在构建后续行时，会发现一个规律就是背包重量 - 当前物品重量上一行的最优解+自身价值与上一行背包重量的最优解进行比较得来，于是有以下代码。

```ts
const knapSack = (weights: number[], values: number[], W: number) => {
  const n = weights.length - 1;
  const dp: number[][] = [[]];
  // 构建第一行
  for (let j = 0; j <= W; j++) {
    if (j < weights[0]) {
      dp[0][j] = 0;
    } else {
      dp[0][j] = values[0];
    }
  }

  for (let j = 0; j <= W; j++) {
    for (let i = 1; i <= n; i++) {
      // 从第一行开始构建，如果这一行没有构建，则赋初始空数组
      if (!dp[i]) {
        dp[i] = [];
      }
      // 如果背包重量小于当前物品重量，则直接赋值上一个最优解即可
      if (j < weights[i]) {
        dp[i][j] = dp[i - 1][j];
      } else {
        // 当前行的最优解就是Math.max(上一行背包重量的最优解, 上一行背包重量减去当前行重量的最优解+当前行的价值)
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]);
      }
    }
  }
  // 最后一行，背包重量的最优解
  return dp[n][W];
};

console.log(knapSack([2, 2, 6, 5, 4], [6, 3, 5, 4, 6], 10)); // 15
```

